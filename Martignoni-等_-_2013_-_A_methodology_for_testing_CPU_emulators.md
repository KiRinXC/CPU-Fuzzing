# A Methodology for Testing CPU Emulators

LORENZO MARTIGNONI, Università degli Studi di Udine ROBERTO PALEARI, ALESSANDRO REINA, GIAMPAOLO FRESI ROGLIA, and DANILO BRUSCHI, Università degli Studi di Milano

A CPU emulator is a software system that simulates a hardware CPU. Emulators are widely used by computer scientists for various kind of activities (e.g., debugging, profiling, and malware analysis). Although no theoretical limitation prevents developing an emulator that faithfully emulates a physical CPU, writing a fully featured emulator is a very challenging and error prone task. Modern CISC architectures have a very rich instruction set, some instructions lack proper specifications, and others may have undefined effects in corner cases. This article presents a testing methodology specific for CPU emulators, based on fuzzing. The emulator is "stressed" with specially crafted test cases, to verify whether the CPU is properly emulated or not. Improper behaviors of the emulator are detected by running the same test case concurrently on the emulated and on the physical CPUs and by comparing the state of the two after the execution. Differences in the final state testify defects in the code of the emulator. We implemented this methodology in a prototype (named as EmuFuzzer), analyzed five state-of-the-art IA-32 emulators (QEMU, Valgrind, Pin, BOCHS, and JPC), and found several defects in each of them, some of which can prevent proper execution of programs.

Categories and Subject Descriptors: D.2.5 [Software Engineering]: Testing and Debugging; D.2.8 [Software Engineering]: Metrics-Complexity measures, performance measures

General Terms: Reliability, Verification

Additional Key Words and Phrases: Software testing, fuzzing, emulation, automatic test generation

## ACM Reference Format:

Martignoni, L., Paleari, R., Reina, A., Roglia, G. F., and Bruschi, D. 2013. A methodology for testing CPU emulators. 2013 ACM Trans. Softw. Eng. Methodol. 22, 4, Article 29 (October 2013), 26 pages. DOI: http://dx.doi.org/10.1145/2522920.2522922

## 1. INTRODUCTION

In Computer Science, the term "emulator" is typically used to denote a piece of software that simulates a hardware system [Lichstein 1969]. Different hardware systems can be simulated: a device [Google Inc. 2011], a CPU (Pin [Luk et al. 2005] and Valgrind [Nethercote 2004]), and even an entire PC system (QEMU [Bellard 2005], BOCHS [Lawton 1996], JPC [Preston et al. 2007], and Simics [Magnusson et al. 2002]). Emulators are widely used today for many applications: development, debugging, profiling, security analysis, etc. For example, the NetBSD AMD64 port was initially developed using an emulator [netbsd64 2011].

---

This article is a revised and extended version of the conference paper "Testing CPU Emulators", presented at ISSTA 2009.

Authors' addresses: L. Martignoni, Dipartimento di Fisica, Università degli Studi di Udine, Italy; email: lorenzo.martignoni@uniud.it; R. Paleari, A. Reina, G. F. Roglia, and D. Bruschi, Dipartmento de Informatica, Università degli Studi di Milano, Italy; email: \{roberto, gianz, bruschi\}@security.dico.unimi.it; alessandro.reina@unimi.it.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212) 869-0481, or permissions@acm.org.

(c) 2013 ACM 1049-331X/2013/10-ART29 \$15.00

DOI: http://dx.doi.org/10.1145/2522920.2522922

---

The Church-Turing thesis implies that any effective computational method can be emulated within any other. Consequently, any hardware system can be emulated via a program written with a standard programming language. Despite the absence of any theoretical limitation that prevents the development of a correct and complete emulator, from the practical point of view, the development of such a software is very challenging. This is particularly true for CPU emulators, that simulate a physical CPU. Indeed, the instruction set of a modern CISC CPU is very rich and complex. Moreover, the official documentation of CPUs often lacks the description of the semantics of certain instructions in certain corner cases and sometimes contains inaccuracies (or ambiguities). Although several good tools and debugging techniques exist [Myers 1978], developers of CPU emulators have no specific technique that can help them to verify whether their software emulates the CPU by following precisely the specification of the vendors. As CPU emulators are employed for a large variety of applications, defects in their code might have cascading implications. Imagine, for example, what consequences the existence of any defect in the emulator used for porting NetBSD to AMD64 would have had on the reliability of the final product.

Assuming that the physical CPU is correct by definition, the ideal CPU emulator has to mimic exactly the behavior of the physical CPU it is emulating. On the contrary, an approximate emulator deviates, in certain situations, from the behavior of the physical CPU. There are particular examples of approximate emulators in literature [Ferrie 2006; Ormandy 2007; Quist and Smith 2006; Rutkowska 2004; Raffetseder et al. 2007]. Our goal is to develop a general automatic technique to discover deviations between the behavior of an emulator and of the corresponding physical CPU. In particular, we are interested in investigating deviations (i.e., state of the CPU registers and contents of the memory) which could modify the behavior of a program in an emulated environment. On the other hand, we are not interested in deviations that lead only to internal differences in the state (e.g., differences in the state of CPU caches), because these differences do not affect the behavior of the programs running inside the emulated environment.

In this article, we present a fully automated and black-box testing methodology for CPU emulators, based on fuzzing [Miller et al. 1990]. Roughly speaking such a methodology works as follows. Initially, we automatically generate a very large number of test cases. Strictly speaking, a test case is a single CPU instruction together with an initial environment configuration (CPU registers and memory contents); a more formal definition of a test case is given in Section 3.3. These test cases are subsequently executed both on the physical CPU and on the emulated CPU. Any difference detected in the configurations of the two environments (e.g., register values or memory contents) at the end of the execution of a test case, is considered a witness of an incorrect behavior of the emulator. Given the unmanageable size of the test case space, we adopt two strategies for generating test cases: purely random test case generation and hybrid algorithmic/random test case generation. The latter guarantees that each instruction in the instruction set is tested at least in some selected execution contexts.

We have implemented this testing methodology in a prototype for IA-32, named as EmuFuzzer, and used it to test five state-of-the-art emulators: BOCHS [Lawton 1996], QEMU [Bellard 2005], Pin [Luk et al. 2005], Valgrind [Nethercote 2004], and JPC [Preston et al. 2007]. Although Pin and Valgrind are dynamic instrumentation tools, their internal architecture resembles, in all details, the architecture of traditional emulators and therefore they can suffer from the same problems. We found several deviations in the behaviors of each of the five emulators. Some examples of the deviations we found in these state-of-the-art emulators are reported in Table ${I}^{1}$ . As an example, let us consider the instruction add $\$ 0 \times  1,\left( {\% {eax}}\right)$ , which adds the immediate

---

${}^{1}$ In this article, we use IA-32 assembly and we adopt the AT&T syntax.

---

Table I. Examples of Instructions that Behave Differently when Executed in the Physical CPU and When Executed in an Emulated CPU (that emulates an IA-32 CPU)

<table><tr><td>Instruction</td><td>IA-32</td><td>QEMU</td><td>Valgrind</td><td>$\mathbf{{Pin}}$</td><td>BOCHS</td><td>$\mathbf{{JPC}}$</td></tr><tr><td>lock fcos</td><td>illegal instr.</td><td>lock ignored</td><td>no diff.</td><td>no diff.</td><td>no diff.</td><td>lock ignored</td></tr><tr><td>int1</td><td>trap</td><td>no diff.</td><td>illegal instr.</td><td>no diff.</td><td>general prot. fault</td><td>not supported</td></tr><tr><td>fld1</td><td>fpuip $=$ eip</td><td>fpuip $= 0$</td><td>fpuip $= 0$</td><td>FPU virtualized*</td><td>no diff.</td><td>fpuip $= 0$</td></tr><tr><td>add \$0x1, (%eax)</td><td>(%eax) = 0xd0</td><td>(%eax) = 0xcf</td><td>no diff.</td><td>no diff.</td><td>no diff.</td><td>no diff.</td></tr><tr><td>pop %fs</td><td>%esp = 0xbfdbb108</td><td>no diff.</td><td>no diff.</td><td>%esp = 0xbfdbb106</td><td>no diff.</td><td>segment not present</td></tr><tr><td>pop 0xffffffff</td><td>%esp = 0xbffffe44</td><td>no diff.</td><td>no diff.</td><td>no diff.</td><td>%esp = 0xbffffe48</td><td>no diff.</td></tr></table>

For each instruction, we report the behavior of the physical CPU and the behavior of the emulators (differences are highlighted).

*PIN virtualizes the physical FPU, so floating point instructions are executed natively rather than being emulated.

![0196f769-143f-742b-9d01-4724b8925cc2_3_403_250_746_327_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_3_403_250_746_327_0.jpg)

Fig. 1. Intel x86 instruction format.

$0\mathrm{x}1$ to the byte pointed by the register eax. Assuming that the original value of the byte is $0\mathrm{{xcf}}$ , the execution of the instruction on the physical CPU, and on four of the tested emulators, provides the result 0xd0 . In QEMU, instead, the value is not updated correctly for a certain encoding of the instruction. We also discovered instructions that are correctly executed in the native environment but freeze QEMU and instructions that are not supported by Valgrind and thus generate exceptions. On the other hand, we also found instructions that are executed by Pin and BOCHS but that cause exceptions on the physical CPU. The results obtained witness the difficulty of writing a fully featured and specification-compliant CPU emulator, but also prove the effectiveness and importance of our testing methodology.

To summarize, this article makes the following contributions:

-a fully automated testing methodology, based on fuzz-testing, specific for CPU emulators;

-an optimized algorithm for test case generation that systematically explores the instruction set, while minimizing redundancy;

—a prototype implementation of our testing methodology for IA-32 emulators;

—an extensive testing of five IA-32 emulators that resulted in the discovery of several defects in each of them, some of which represent serious bugs.

This article is organized as follows. Section 2 briefly reviews the main fundamental features of the Intel IA-32 architecture. Section 3 introduces formally the notion of faithful emulation. Section 4 describes in detail our algorithms for test-case generation and how test cases are run to detect if an emulator is not emulating faithfully the CPU. Section 5 evaluates our methodology by presenting the results of the testing of five CPU emulators. Section 6 discusses limitations and future work. Finally, Section 7 presents the related literature, and Section 8 concludes.

## 2. IA-32 INTEL ARCHITECTURE

The IA-32 refers to a family of 32-bit Intel processors that are widely used in many multipurpose environments because of their facilities and performance. In this section, we provide a brief introduction to the IA-32 architecture. For further details, an interested reader can refer elsewhere [Intel 2008].

IA-32 is a CISC architecture, with an incredible number of different instructions and a complex encoding scheme. Instruction length can vary from 1 to 17 bytes. The format of an Intel x86 instruction is depicted in Figure 1. An instruction is composed of different fields: it starts with up to 4 prefixes, followed by an opcode, an addressing specifier (i.e., ModR/M and SIB fields), a displacement and an immediate data field [Intel 2008]. Opcodes are encoded with one, two, or three bytes, but three extra bits of the ModR/M field can be used to denote certain opcodes. In total, the instruction set is composed of more than 700 possible values of the opcode field. The ModR/M field is used in many instructions to specify nonimplicit operands: the Mod and R/M subfields are used in combination to specify either registry operands or to encode addressing modes, while the Reg/Opcode subfield can either specify a register number or, as mentioned before, additional bits of opcode information. The SIB byte is used with certain configurations of the ModR/M field, to specify base-plus-index or scale-plus-index addressing forms. The SIB field is in turn partitioned in three subfields: Scale, Index, and Base, specifying respectively the scale factor, the index register, and the base register. Finally, the optional addressing displacement and immediate operands are encoded in the Displacement and Immediate fields respectively. Since the encoding of the ModR/M and SIB bytes is not trivial at all, the Intel $\times  {86}$ specification provides tables describing the semantics of the 256 possible values each of these two bytes might assume. In conclusion, it is easy to see that elementary decoding operations, such as determining the length of an instruction, require decoding the entire instruction format and interpreting the various fields correctly. In recent years, the advent of several instruction extensions (e.g., Multiple Math eXtension (MMX) and Streaming SIMD Extensions (SSE)) contributed to make the instruction set even more complicated.

The IA-32 architecture supports four basic operating modes: real-address mode, protected mode, virtual-8086 mode, and system management mode. The operating mode of the processor determines which instructions and architectural features are available. Every operating mode implies a well-defined set of instructions and semantics, and some instructions behave differently depending on the mode. For example, instruction can raise different exceptions and can update flags and registers differently when executed in the protected mode and when executed in the virtual-8086 mode.

Any task or program running on an IA-32 processor is given a set of resources for storing code, data, state information, and for executing instructions. These resources constitute the basic execution environment and they are used by both the operating system and users' applications. The resources of the basic execution environment are identified as follows. —Address Space. Any task or program can address a 32-bit linear address space.

—Basic Program Execution Environment. The eight general-purpose registers (eax, ecx, edx, ebx, esp, ebp, esi, edi), the six segment registers (cs, ss, ds, es, fs, gs), the eflags register, and the eip register comprise a basic execution environment in which to execute a set of general-purpose instructions.

- Stack. This is used to support procedure or subroutine calls and the passing of parameters between procedure and subroutines.

$-  \times  {87}$ FPU Registers. This set of registers provides an execution environment for floating point operations.

-MMX Registers and XMM Registers. These registers are used by dedicated instructions designed for accelerating multimedia and communication applications.

In addition to these resources, the IA-32 architecture provides the following resources as part of its system-level architecture.

-I/O Ports. The IA-32 architecture supports a transfer of data to and from input/output ports;

—Control Register. The five control registers (cr0 through cr4) determine the operating mode of the processor and the characteristics of the currently executing task; -Memory Management Register. The gdtr, idtr, task register, and ldtr specify the locations of data structures used in protected mode memory management; —Debug Register. The debug registers (db0 through db7) control and allow monitoring of the processor's debugging operations; —Memory-Type Range Registers. The memory type range registers are used to assign memory type to regions of memory such as: uncacheable, write combining, write through, write back, and write protected type;

—Machine-Specific Registers. The processor provides a variety of machine specific registers (MSR) that are used to control and report on processor performance;

—Machine Check Registers. The machine check registers consist of a set of control, status, and error-reporting MSRs that are used to detect and report on hardware (machine) errors. Specifically the IA-32 processors implement a machine check architecture that provides a mechanism for detecting and reporting errors such as: system bus errors, ECC errors, parity errors, cache errors, and TLB errors.

CPU emulators have to offer an execution environment suitable for running an application or even a commodity operating system. Given the complexity of IA-32 architecture, fully featured CPU emulators for this architecture are complex pieces of software. Our claim is that this complexity is the cause of a large number of defects.

## 3. OVERVIEW

This section describes how CPU emulators work, formalizes our notion of faithful emulation of a physical CPU, and sketches the idea behind our testing methodology.

#### 3.1.CPU Emulators

By CPU emulator, we mean a piece of software system that simulates the execution environment offered by a physical CPU. The execution of a binary program $P$ is emulated when each instruction of $P$ is executed by a CPU emulator. Inside a CPU emulator instructions are typically executed using either interpretation or just-in-time translation. Here, we are only interested in emulators adopting the former strategy, in such case instructions are executed by mimicking in every detail the behavior of the physical CPU, obviously operating on the resources of the emulated execution environment.

The execution environment can be properly emulated even if some internal components of the physical CPU are not considered (e.g., the instruction cache): as these components are used transparently by the physical CPU, no program can access them. Similarly, emulated execution environments can contain extra, but transparent, components not found in hardware execution environments (e.g., the cache used to store translated code).

### 3.2. Faithful CPU Emulation

Given a physical CPU ${\mathcal{C}}_{P}$ , we denote with ${\mathcal{C}}_{E}$ a software CPU emulator that emulates ${\mathcal{C}}_{P}$ . Our ideal goal is to automatically analyze a given ${\mathcal{C}}_{E}$ to tell whether it faithfully emulates ${\mathcal{C}}_{P}$ . In other words, we would like to tell if ${\mathcal{C}}_{E}$ behaves equivalently to ${\mathcal{C}}_{P}$ , in the sense that any attempt to execute a valid (or invalid) instruction results in the same behavior in both ${\mathcal{C}}_{P}$ and ${\mathcal{C}}_{E}$ . In the following, we introduce some definitions which will help us to precisely define this equivalence notion.

Let $N$ be the number of bits used by a CPU $\mathcal{C}$ for representing its memory addresses as well as the registers contents. A state $s$ of $\mathcal{C}$ is represented by the following tuple $s = \left( {{pc}, R, M, E}\right)$ where

$- {pc} \in  \left\{  {0,\ldots ,{2}^{N} - 1}\right\}   \cup$ halt;

$- R =  < {r}_{1},\ldots ,{r}_{k} > ;{r}_{i} \in  \left\{  {0,\ldots ,{2}^{N} - 1}\right\}$ is the value contained in the $i$ th CPU register; $- M =  < {b}_{0},\ldots ,{b}_{{2}^{N} - 1} > ;{b}_{i} \in  \{ 0,\ldots ,{255}\}$ is the contents of the $i$ th memory byte;

$\;E \in  \{  \bot$ , illegal in struction, division by zero, general protection fault,... $\}$ denotes the exception that occurred during the execution of the last instruction; the special exception state $\bot$ indicates that no exception occurred.

We denote by $\mathcal{S}$ the set of all states of a CPU. The behavior of a CPU $\mathcal{C}$ is modeled by a transition system $\left( {\mathcal{S},{\delta }_{\mathcal{C}}}\right)$ , where ${\delta }_{\mathcal{C}} : \mathcal{S} \rightarrow  \mathcal{S}$ is the state-transition function which maps a CPU state $s = \left( {{pc}, R, M, E}\right)$ into a new state ${s}^{\prime } = \left( {p{c}^{\prime },{R}^{\prime },{M}^{\prime },{E}^{\prime }}\right)$ by executing the instruction whose address is specified by the ${pc}$ . The transition function $\delta$ is defined as follows:

$$
{\delta }_{\mathcal{C}}\left( {{pc}, R, M, E}\right) \overset{\text{ def }}{ = }\left\{  \begin{array}{ll} \left( {{pc}, R, M, E}\right) & \text{ if }{pc} = \text{ halt } \vee  E \neq   \bot  , \\  \left( {{pc}, R, M,{E}^{\prime }}\right) & \text{ if an exception occurs,} \\  \left( {p{c}^{\prime },{R}^{\prime },{M}^{\prime }, \bot  }\right) & \text{ otherwise. } \end{array}\right.
$$

When ${E}^{\prime } \neq   \bot$ the contents of the registers ${R}^{\prime }$ , of the memory ${M}^{\prime }$ and of $p{c}^{\prime }$ are updated according to the semantics of the executed instruction. On the other side, if an exception occurs, then we assume for simplicity ${}^{2}$ that ${\delta }_{\mathcal{C}}\left( {{pc}, R, M, E}\right)  = \left( {{pc}, R, M,{E}^{\prime }}\right)$ . When the last instruction of a program is executed, the program counter is set to halt, and from that point on the state of the environment is not updated anymore.

We can now formally define what it means for ${\mathcal{C}}_{E}$ to be a faithful emulator of ${\mathcal{C}}_{P}$ . Intuitively, ${\mathcal{C}}_{E}$ faithfully emulates ${\mathcal{C}}_{P}$ if the state-transition function ${\delta }_{{\mathcal{C}}_{E}}$ that models ${\mathcal{C}}_{E}$ is semantically equivalent to the function ${\delta }_{{\mathcal{C}}_{P}}$ that models ${\mathcal{C}}_{P}$ . That is, for each possible state $s \in  \mathcal{S},{\delta }_{{\mathcal{C}}_{P}}$ and ${\delta }_{{\mathcal{C}}_{E}}$ always transition into the same state. More formally, ${\mathcal{C}}_{E}$ faithfully emulates ${\mathcal{C}}_{P}$ iff:

$$
\forall s \in  \mathcal{S} : {\delta }_{{\mathcal{C}}_{P}}\left( s\right)  = {\delta }_{{\mathcal{C}}_{E}}\left( s\right) .
$$

### 3.3. Fuzzing and Differential Testing of CPU Emulators

Given a physical CPU ${\mathcal{C}}_{P}$ and an emulator ${\mathcal{C}}_{E}$ , proving that ${\mathcal{C}}_{E}$ faithfully emulates ${\mathcal{C}}_{P}$ is unfeasible as it requires the verification of a huge number of states. Thus, our aim is to find witnesses of the fact that an emulator ${\mathcal{C}}_{E}$ does not faithfully emulate ${\mathcal{C}}_{P}$ .

We achieve this goal by generating a number of test cases, that is, CPU states $s = \left( {{pc}, R, M, E}\right)$ , and looking for a test case $\bar{s}$ which proves that ${\mathcal{C}}_{E}$ unfaithfully emulates ${\mathcal{C}}_{P}$ , that is, ${}^{3}$

$$
\bar{s} \in  \mathcal{S} : {\delta }_{{\mathcal{C}}_{P}}\left( \bar{s}\right)  \neq  {\delta }_{{\mathcal{C}}_{E}}\left( \bar{s}\right) .
$$

Our approach for finding $\bar{s}$ is based on fuzzing [Miller et al. 1990] (for test case generation) and differential testing [McKeeman 1998] (to compare ${\delta }_{{\mathcal{C}}_{P}}\left( s\right)$ against ${\delta }_{{\mathcal{C}}_{E}}\left( s\right)$ ). Once a test case $s$ has been generated we set the state of both ${\mathcal{C}}_{P}$ and ${\mathcal{C}}_{E}$ to $s$ . Then, we execute the instruction pointed by ${pc}$ in both ${\mathcal{C}}_{P}$ and ${\mathcal{C}}_{E}$ . At the end of the execution of the instruction, we compare the final state. If no difference is found, then ${\delta }_{{\mathcal{C}}_{P}}\left( s\right)  = {\delta }_{{\mathcal{C}}_{E}}\left( s\right)$ holds. On the other hand, a difference in the final state proves that ${\delta }_{{\mathcal{C}}_{P}}\left( s\right)  \neq  {\delta }_{{\mathcal{C}}_{F}}\left( s\right)$ and therefore that ${\mathcal{C}}_{E}$ does not faithfully emulate ${\mathcal{C}}_{P}$ .

Figure 2 shows an example of our testing methodology. ${}^{4}$ We run two different test cases, namely $s$ and $\bar{s}$ . To ease the presentation, in the figure we report only the relevant state information (three registers and the contents of few memory locations) and we represent the program counter by underlining the instruction it is pointing to. Furthermore, when the states of the two environments do not differ, we graphically overlap them. The first test case $s$ (Figure 2(a)) consists of executing the instruction mov $\$ 0\mathrm{x}1,\%$ eax. We set the state of ${\mathcal{C}}_{P}$ and ${\mathcal{C}}_{E}$ to $s$ and we execute in both the instruction pointed by the program counter. As there is no difference in the final states, we conclude that ${\delta }_{{\mathcal{C}}_{E}}\left( s\right)  = {\delta }_{{\mathcal{C}}_{P}}\left( s\right)$ . The second test case $\bar{s}$ (Figure 2(b)) consists of executing the instruction push %fs, that saves the segment register ${fs}$ on the stack. Although the register is 16 bits wide, the IA-32 specification dictates that, when operating in 32-bit mode, the CPU has to reserve 32 bits of the stack for the store. In the example, we observe that ${\mathcal{C}}_{P}$ leaves the upper 16 bits of the stack untouched, while ${\mathcal{C}}_{E}$ overwrites them with zero (the different bytes are highlighted in the figure). The two final states differ because the contents of their memory differs, consequently, ${\delta }_{{\mathcal{C}}_{P}}\left( \bar{s}\right)  \neq  {\delta }_{{\mathcal{C}}_{E}}\left( \bar{s}\right)$ . That proves that ${\mathcal{C}}_{E}$ does not faithfully emulate ${\mathcal{C}}_{P}$ .

---

${}^{2}$ Exceptions actually modify CPU registers and memory. However, in our model, when an exception occurs execution is interrupted, so these modifications can be safely ignored.

${}^{3}$ Here we assume that $\delta$ is a function (hence, deterministic) for a specific CPU model. Indeed, even if for some instructions the CPU specifications are not completely defined, it turns out that, given an initial state, the behavior of any instruction is deterministic. Obviously, CPU undefined behaviors are not documented in the released specifications, therefore emulators do not simulate them.

${}^{4}$ This example reflects a real defect we have found in QEMU using our testing methodology.

---

![0196f769-143f-742b-9d01-4724b8925cc2_7_169_244_1222_937_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_7_169_244_1222_937_0.jpg)

Fig. 2. An example of our testing methodology with two different test cases ( $s$ and $\bar{s}$ ): (a) no deviation in the behavior is observed, (b) the words at the top of the stack differ (highlighted in gray).

## 4. EMUFUZZER

The development of the approach briefly described in the previous section requires overcoming two major difficulties. First, as the potential number of states in which an emulator should be tested is prohibitively large, we have to focus our efforts on selecting a small subset of states, which maximizes the completeness of the testing. Second, the detection of deviations in the behaviors of the two environments requires us to properly setup and inspect their state at the end of the execution of each test case. Thus, we need to develop a mechanism to efficiently initialize and compare the state of the two environments. In this section, we provide a detailed description of how these difficulties have been overcome.

Although the methodology we are proposing is architecture independent, our implementation, called EmuFuzzer, is currently specific for IA-32. This choice is solely motivated by our limited hardware availability. Nevertheless, minor changes to the implementation would be sufficient to port it to different architectures. To ease the development, the current version of the prototype runs entirely in user-space and thus can only verify the correctness of the emulation of unprivileged instructions and whether privileged instructions are correctly prohibited. EmuFuzzer deals with two different types of emulators: process emulators that emulate a single process at a time (e.g., Valgrind, PIN, and QEMU), and whole-system emulators that emulate an entire system (e.g., BOCHS, JPC, and QEMU ${}^{5}$ ).

---

void main(   ) \{

	void *p;

	// Code of the test case

	char code[] = "\\xB8\\xEF\\xBE\\xAD\\xDE";

	// Initialize the memory with random data

	for $\left( {\mathrm{p} = 0\mathrm{x}0;\mathrm{p} < \text{FILE_SIZE;}\mathrm{p} +  = \text{PAGE_SIZE}}\right) \{$

		f = open(FILE_WITH_RANDOM_DATA, O_RDWR);

		mmap(p, PAGE_SIZE, ..., MAP_FIXED, f, 0);

	\}

	// Initialize the registers with random data

	asm ("mov RANDOM, %eax") ;

	asm ("mov RANDOM, %ebx") ;

	asm ("mov RANDOM, %ecx") ;

	...

	// Execute the code of the test case (pc = code)

	((void(*)(   )) code)(   );

---

Fig. 3. Pseudocode of the program which generates a test case.

### 4.1. Test Case Generation

As just mentioned, in our testing methodology, a test case $s = \left( {{pc}, R, M, \bot  }\right)$ is a state of the environment under test. The memory contains the code that will be executed by the CPU, as well as the corresponding data part of which is contained in $R$ . To generate test cases we adopt two strategies: (I) random test case generation, where both data and code are random, and (II) CPU-assisted test case generation, where data is random, and code is generated algorithmically, with the support of the physical and of the emulated CPUs. The advantage of using two different strategies is a better coverage of the test case space. Test cases are generated by an assembly program, which contains instructions for environment initialization, that is, memory and registers, and loads into the test case memory one single instruction, that is, the instruction we want to test. Figure 3 shows a C pseudocode of such a program. This program initializes the state of the environment, by loading the memory content (lines 6-10) and the data in the CPU registers (lines 12-15), and subsequently it triggers the execution of the code of the test case (line 19). The program is compiled with appropriate compiler flags to generate a tiny self-contained executable (i.e., that does not use any shared library).

There are other possible approaches to generate the code of test cases. For example, one can generate assembly instructions and then compile them with an assembler or use a disassembler to detect which sequences of bytes encode a legal instruction. However, limitations of the assembler or of the disassembler negatively impact on the completeness of the generated test cases. Besides our approach, detailed in the following, none of the ones just mentioned can guarantee no false-negative (i.e., that a sequence of bytes encoding a valid instruction is considered invalid).

---

${}^{5}$ QEMU supports both whole-system and process emulation.

---

4.1.1. Random Test Case Generation. In random test case generation, both data and code of the test case are generated randomly. The memory is initialized by mapping a file filled with random data. For simplicity, the same file is mapped multiple times at consecutive addresses until the entire user-portion of the address space is allocated. To avoid a useless waste of memory, the file is lazily mapped in memory, such that physical memory pages are allocated only if they are accessed. The CPU registers are also initialized with random values. As we work in user-space, we cannot allocate the entire address space because a part of it is reserved for the kernel. Therefore, to minimize page faults when registers are used to dereference memory locations, we make sure the value of general purpose registers fall around the middle of the allocated user address space. The rationale is to maximize the probability that, for any instruction, memory operands refer to valid locations. Obviously, code generated with this random approach might contain more than one instruction.

4.1.2. CPU-Assisted Test Case Generation. A thorough testing of an emulator requires us to verify that each possible instruction is emulated faithfully. Unfortunately, the pure random test case generation approach presented earlier is very unlikely to cover the entire instruction set of the architecture (the majority of CPU instructions require operands encoded using specific encoding and others have opcodes of multiple bytes). Ideally, we would have to enumerate and test all possible instances of instructions (i.e., combinations of opcodes and operands). Clearly this is not feasible. To narrow the problem space, we identify all supported instructions and then we test the emulator using only few peculiar instances of each instruction. That is, for each opcode, we generate test cases by combining the opcodes with some predefined operand values. As in random-test case generation, the data of the test case are random.

Naïve Exploration of the Instruction Set. Our algorithm for generating the code of a test case leverages both the physical and the emulated CPUs, in order to identify byte sequences representing valid instructions. We call our algorithm ${CPU}$ -assisted test case generation. The algorithm enumerates the sequences of bytes and discards all the sequences that do not represent valid code. The CPU is the oracle that tells us if a sequence of bytes encodes a valid instruction or not: sequences that raise illegal instruction exceptions do not represent valid code. We run our algorithm on the physical and on the emulated CPUs and then we take the union of the two sets of valid instructions found. The sequences of bytes that cannot be executed on both CPUs are discarded because they do not represent interesting test cases: we know in advance that the CPUs will behave equivalently (i.e., ${E}^{\prime } =$ illegal instruction). On the other hand, a sequence of bytes that can be executed on at least one of the two CPUs is considered interesting because it can lead to one of the following situations: (I) it represents a valid instruction for one CPU and an invalid instruction for the other; (II) it encodes a valid instruction for both CPUs but, once executed, causes the CPUs to transition to two different states.

Optimized Exploration of the Instruction Set. We can imagine representing all valid CPU instructions as a tree, where the root is the empty sequence of bytes and the nodes on the path from the root to the leaves represent the various bytes that compose the instruction. Figure 4(a) shows an example of such a tree. Our algorithm exploits a particular property of this tree in order to optimize the traversal and to avoid the generation of redundant test cases: the majority of instructions have one or more operands and thus multiple sequences of bytes, sharing the same prefix, encode the same instruction, but with different operands. In the following, we describe an example of the optimized instruction set exploration; further details are then given in Section 4.2.

![0196f769-143f-742b-9d01-4724b8925cc2_10_399_252_761_1092_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_10_399_252_761_1092_0.jpg)

Fig. 4. Example of CPU-assisted test case generation for the opcode 6605 (mov imm16,%x): (a) naïve and (b) optimized generation (paths in gray are not explored).

As an example, let us consider the ${2}^{16}$ sequences of bytes from 66050000 to 66 05FFFF that represent the same instruction, add imm16,%ax, with just different values of the 16-bit immediate operand. Figure 4(a) shows the tree representation of the bytes that encode this instruction. The subtree rooted at node 05 encodes all the valid operands of the instruction. Without any insight on the format of the instruction, one has to traverse in depth-first ordering the entire subtree and to assume that each path represents a different instruction. Then, for each traversed path, a test case must be generated. Our algorithm, by traversing only few paths of the subtree rooted at node 05 , is able to infer the format of the instruction: (I) the existence of the operand, (II) which bytes of the instruction encode the opcode and which ones encode the operand, and (III) the type of the operand. Once the instruction has been decoded (in the case of the example the opcode is 6605 and it is followed by a 16-bit immediate), without having to traverse the remaining paths, our algorithm generates a minimal set of test cases with a very high coverage of all the possible behaviors of the instruction. These test cases are generated by fixing the bytes of the opcode and varying the bytes of the operand. The intent is to select operand values that more likely generate the larger class of behaviors (e.g., to cause an overflow or to cause an operation with carry). For example, for the opcode 6605, our algorithm decodes the instruction by exploring only ${0.5}\%$ of the total number of paths and generates only 56 test cases. The optimized tree traversal is shown in Figure 4(b), where paths in gray are those that do not need to be explored. The heuristics on which our rudimentary, but faithful, instructions decoder is built on is described in Section 4.2. It is worth noting that, unlike traditional disassemblers, we decode instructions without any prior knowledge of their format. Thus, we can infer which bytes of an instruction represent the opcode, but we do not know which high-level instruction (e.g., add) is associated with the opcode.

#### 4.2.The Decoder

The optimized traversal algorithm, just described in Section 4.1.2, requires the ability to decode an instruction, and to identify its opcode and operands. Such a task is undertaken by a specific module (less than 500 lines of code) which we named the decoder. The decoder uses the CPU as an oracle: given a sequence of bytes, the CPU tells us if that sequence encodes a valid instruction or not [Paleari et al. 2010]. The decoding is trial-based: we mutate an executable sequence of bytes, we query the oracle to see which mutations are valid and which are not, and from the result of the queries we infer the format of the instruction. Mutations are generated following specific schemes that reflect the ones used by the CPU to encode operands [Intel 2008].

In the following, we briefly describe how the decoder infers the length of an instruction and the format of nonimplicit operands, assuming to know only the encoding schemes used to encode operands.

4.2.1. Determining Instruction Length. For determining the length of a given instruction, the decoder exploits the fact that the CPU fetches, and decodes, the bytes of the instruction incrementally. Given an arbitrary sequence of bytes $B = {b}_{1}\ldots {b}_{n}$ , the first goal is to detect if the bytes represent a valid instruction. The decoder executes the input string $B$ in a specially crafted execution environment, such that every fetch of the bytes composing the instruction can be observed.

The decoder partitions $B$ into subsequences of incremental length $\left( {{B}_{1} = {b}_{1},{B}_{2} = {b}_{1}{b}_{2}}\right.$ , $\left. {\ldots ,{B}_{n} = {b}_{1}\cdots {b}_{n}}\right)$ and then executes one subsequence after another, using single-stepping. The goal is to intercept the fetch of the various bytes of the instruction, which is achieved by placing the $i$ th subsequence ${B}_{i}$ (with $i = 1\ldots n$ ) in memory such that it overlaps two adjacent memory pages, $m$ and ${m}^{\prime }$ . The first $i$ bytes are located at the end of $m$ , and the remaining(n - i)bytes at the beginning of ${m}^{\prime }$ . The two pages have special permissions: $m$ allows read and execute accesses, while ${m}^{\prime }$ prohibits any access. When the instruction is executed, the $i$ bytes in the first page are fetched incrementally by the CPU. If the instruction is longer than $i$ bytes, the CPU will try to fetch the next byte, ${\left( i + 1\right) }^{th}$ , and will raise a page fault exception (where the faulty address corresponds to the base address of ${m}^{\prime }$ ) because the page containing the byte being read, ${m}^{\prime }$ , is not accessible. In this case, the decoder repeats the process with the string ${B}_{i + 1}$ , that is placing the $i + 1$ th bytes at the end of $m$ and the remaining at ${m}^{\prime }$ . On the other hand, if the instruction contained in the page $m$ has the correct length, it will be executed by the CPU without accessing the bytes in ${m}^{\prime }$ . In such a situation the instruction can be both valid and invalid. The instruction is valid if it is executed without causing any exception; it is also valid if the CPU raises a page fault (in this case, the faulty address does not correspond to the base address of ${m}^{\prime }$ ) or a general protection fault exception. A page fault exception occurs if the instruction tries to read or write data from the memory; a general protection fault exception is raised if the instruction has improper operands. The instruction is invalid instead, if the CPU raises an illegal instruction exception. In both cases, the decoder returns.

Figure 5 shows our CPU-assisted decoder in action on two different sequences of bytes, one valid and one invalid. The first sequence is $B = {88}$ b7310fa ca..., corresponding to the instruction mov %dh, \$0xcafa1053(%edi). The decoder allocates two adjacent memory pages and removes any permission from the second one. Then, it starts with the first subsequence ${B}_{1} = {88}$ . The byte is positioned at the end of the page and then executed through single stepping. The CPU fetches and tries to decode the instruction but, since the instruction is longer than one byte, it tries to fetch the $\frac{\text{next bytes from the protected page, raising a page fault.}}{\text{The decoder detects the fault}}$ and concludes that the instruction is longer than one byte (in our example, the faulty address is $0 \times  {20000}$ , the base address of the second page). It repeats the procedure with ${B}_{2} = {88}\mathrm{b}7$ and gets the same result. It tries again with ${B}_{3},{B}_{4},{B}_{5}$ , and finally tries with six bytes. Since the instruction is six bytes long, the CPU executes the instruction without accessing the protected memory page. However, the instruction writes into the memory and thus causes a page fault. As in this case, the faulty address (0x78378943)differs from the address of the protected page, our decoder can decide that the instruction is valid and that it is six bytes long. It is worth noting that a sequence of bytes cannot encode, at the same time, a valid instruction and a prefix of a longer instruction. Indeed, such a situation would be ambiguous for the CPU. The third byte sequence in the example of Figure 5(b) is $B = \left\{  \begin{array}{ll} 0 & 0 \\  0 & \mathrm{c}0\cdots  \end{array}\right.$ and represents an invalid instruction. Exactly as before, our decoder executes the first two subsequences ${B}_{1}$ and ${B}_{2}$ and detects that the instruction is potentially longer because the CPU fetches a third byte from the protected page. When ${B}_{3}$ is executed, the CPU does not fetch more bytes but instead raises an illegal instruction exception, testifying that ${B}_{3}$ is neither a valid instruction, nor a valid prefix for longer instructions.

![0196f769-143f-742b-9d01-4724b8925cc2_12_393_243_769_1391_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_12_393_243_769_1391_0.jpg)

Fig. 5. Computation of the length of instructions using our CPU-assisted instruction decoder: (a) valid and (b) invalid instructions.

4.2.2. Decoding Nonimplicit Operands. Once the decoder finds the length of an instruction the decoder tries to infer the type and the value of the non-implicit operands of the instruction (i.e., the operands that are not implicitly encoded in the opcode of the instruction). The technique used by our decoder to achieve this goal is an extension of the technique described in the previous paragraphs. Currently, our CPU-assisted decoder is capable of decoding addressing-form specifier operands and immediate operands.

Any Intel $\times  {86}$ instruction (Figure 1) is composed of an optional prefix, an opcode, and optional operands. To ease the presentation we assume that the instructions have no prefix; in practice, prefixes are detected using a white-list and considered part of the opcode. Given an instruction, encoded by the sequence of bytes $B = {b}_{1}\cdots {b}_{n}$ , the format of the operands is detected by performing a series of tests on some instructions derived by changing the bytes of $B$ that follow the opcode and represent the operands of the instruction. If the opcode is $j$ bytes long, the remaining $n - j$ bytes represent the operands. Each type of operand is encoded using a different encoding: immediate operands (Imm) are encoded as is, addressing-form specifier operands (Addr) are encoded using ModR/M and SIB encoding, and $\operatorname{Imm} \cup  {Addr} \neq  \operatorname{Imm} \cap  {Addr}$ (i.e., an immediate operand does not necessarily represent a valid addressing-form specifier operand, and vice-versa). Therefore, given an instruction encoded by the sequence of bytes $B = {b}_{1}\cdots {b}_{n}$ , we expect a new sequence ${B}^{\prime } = {b}_{1}\cdots {b}_{j}{b}_{j + 1}^{\prime }\cdots {b}_{m}^{\prime }$ , where ${b}_{j + 1}^{\prime }\cdots {b}_{m}^{\prime }$ represents a new operand of the same type of ${b}_{j + 1}\cdots {b}_{m}$ , to be valid. Contrarily, we expect another sequence of bytes $\overset{―}{B} = {b}_{1}\cdots {b}_{j}\overset{―}{{b}_{j + 1}}\cdots \overset{―}{{b}_{m}}$ , where $\overset{―}{{b}_{j + 1}}\cdots \overset{―}{{b}_{m}}$ represent an operand of a different type, to be invalid. Therefore, if an instruction with a $j$ bytes long opcode has an immediate operand, then the following holds:

$$
\forall {b}_{j + 1}^{\prime }\ldots {b}_{m}^{\prime } \in  \operatorname{Imm},{B}^{\prime } = {b}_{1}\ldots {b}_{j}{b}_{j + 1}^{\prime }\ldots {b}_{m}^{\prime }\text{is valid.}
$$

In other words, the bytes following the opcode encode an immediate operand if the combination of the opcode with all the possible immediate operands always gives valid instructions. Fortunately, with few tests it is possible to estimate if the previous equation holds. In fact, it is sufficient to verify if it holds for a small number of operands in $\operatorname{Imm} \smallsetminus  {Addr}$ . The same applies for an instruction with an addressing-form specifier operand. Our current prototype of the decoder uses only five tests to decode addressing-form specifier operands and four to detect 32-bit immediate operands. Basically, in order to infer if an instruction refers to an operand in memory, we use specific configurations of the ModR/M and SIB fields (e.g., [EAX] , [EAX]+disp, [EBP]+disp, etc.). Since the opcode can have a variable length (from one to three bytes), our CPU-assisted decoder performs the aforementioned tests with opcodes of incremental length (i.e., $j = 1,2,3$ ).

Figure 6 shows some of the tests performed by our CPU-assisted instruction decoder to infer the format of the operands of two instructions: the first instruction has an addressing-form specifier operand and the second one a 32-bit immediate operand. For the first instruction, the decoder initially assumes that the opcode is one byte long, and performs the analysis of the remaining bytes to detect if they encode an addressing-form specifier operand. To do that it combines the opcode 88 with other valid addressing-form specifier operands of variable length, some of which cannot be interpreted as immediate operands. The first test consists of replacing the alleged operand with a single byte operand and in executing the resulting string. The CPU successfully executes the instruction. The same procedure is repeated with operands of different length (two, three, and seven bytes). All the sequences of bytes are found to encode valid instructions; every execution of the tested instructions raise a page fault exception where the faulty address does not correspond to the base address of the protected page. Therefore, the input instruction is composed of a single byte opcode followed by an addressing-form specifier operand (b7 53 10 fa ca, in 6). The same procedure is applied also to the second instruction. The addressing-form specifier operand decoding fails, so the decoder attempts to verify whether the last four bytes of the instruction encode a 32-bit immediate. All tests performed are passed.

### 4.3. Test Case Execution

Given a test case, we have to execute it both on the physical and emulated CPUs and then compare their state at the end of the execution. In order to perform such a task we have developed two different applications, the first one denoted by $E$ runs on the emulator and the second one, denoted by $P$ will run on the physical CPU as a user space application. Initially, we start the execution of the test case on the emulator. As soon as the initialization of the state of the emulator is completed, it is replicated to the physical CPU. As registers and memory are initialized with random values, replication is required to guarantee that test cases are executed on the physical and emulated environments starting from the same initial state. Then, the code of the test case is executed in the two environments and, at the end of the execution, we compare the final state. In the remainder of this section, we describe the main steps performed for the execution of a test case and we will also provide details on the strategy we adopted for instrumenting the emulator and the physical environment in order to execute respectively the programs $E$ and $P$ . For simplicity, the details that follow are specific for the testing of process emulators. Nonetheless, the implementation for testing whole-system emulators only requires the addition of introspection capabilities to isolate the execution of the test case program [Garfinkel and Rosenblum 2003].

4.3.1. Executing a Test Case. The execution flow of a test case is summarized in Figure 7 and described in detail in the following paragraphs, where the following notation will be adopted. The state of the emulator ${\mathcal{C}}_{E}$ prior and after the execution of a test case respectively ${s}_{E} = \left( {p{c}_{E},{R}_{E},{M}_{E},{E}_{E}}\right)$ and ${s}_{E}^{\prime } = \left( {p{c}_{E}^{\prime },{R}_{E}^{\prime },{M}_{E}^{\prime },{E}_{E}^{\prime }}\right)$ . Similarly, for ${\mathcal{C}}_{P}$ , we use respectively ${s}_{P} = \left( {p{c}_{P},{R}_{P},{M}_{P},{E}_{P}}\right)$ and ${s}_{P}^{\prime } = \left( {p{c}_{P}^{\prime },{R}_{P}^{\prime },{M}_{P}^{\prime },{E}_{P}^{\prime }}\right)$ .

Setup of the Emulated Execution Environment. The CPU emulator is started and it begins to execute the program $E$ generating and executing the test case $\left( {L}_{\mathrm{E}1}\right)$ until the state of the environment is completely initialized $\left( {L}_{\mathrm{E}2}\right)$ . In other words, $E$ is executed without interference until the execution reaches $p{c}_{E}$ , that is, the address of the code of the test case (see line 19, Figure 3). $E$ initializes the emulator memory by mapping a file filled with random data. For simplicity, the same file is mapped multiple times at consecutive addresses until the entire user-portion of the address space is allocated. To avoid a useless waste of memory, the file is lazily mapped in memory, such that physical memory pages are allocated only if they are accessed. As we discussed in Section 4.1.1, CPU registers are also initialized with random values.

![0196f769-143f-742b-9d01-4724b8925cc2_15_389_308_790_1652_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_15_389_308_790_1652_0.jpg)

Fig. 6. Decoding of nonimplicit operands using our CPU-assisted instruction decoder: instructions with (a) addressing-form specifier operand and (b) immediate operand.

![0196f769-143f-742b-9d01-4724b8925cc2_16_340_246_871_1119_0.jpg](images/0196f769-143f-742b-9d01-4724b8925cc2_16_340_246_871_1119_0.jpg)

Fig. 7. Logic of the execution of a test case (t.c., for short). $\square$ denotes the execution of the test case and denotes the execution of the code of the logic.

Setup of the Physical Execution Environment. When the state of the emulated environment has been set up (i.e., when the execution has reached $p{c}_{E}$ ), the initial state, ${s}_{E} = \left( {p{c}_{E},{R}_{E},{M}_{E},{E}_{E}}\right)$ , can be replicated into the physical environment. The emulator notifies and transfers the state of the CPU registers to $P\left( {L}_{\mathrm{E}3}\right)$ . Initially, the exception state ${E}_{E}$ is always assumed to be $\bot$ . Note that the memory state of the physical CPU ${M}_{P}$ is not synchronized with the emulated CPU. At the beginning, only the memory page containing the code of the test case is copied into the physical environment $\left( {L}_{\mathrm{P}1}\right.$ and ${L}_{\mathrm{E}4}$ ). The remaining memory pages are instead synchronized on-demand the first time they are accessed, as it will be explained in detail in the next paragraph. At this point we have that ${R}_{E} = {R}_{P},{E}_{E} = {E}_{P} =  \bot$ , but ${M}_{E} \neq  {M}_{P}$ (the only page that is synchronized is the one with the code).

Test Case Execution on the Physical CPU. The execution of the code of the test case on the physical CPU starts, beginning from program address $p{c}_{P} = p{c}_{E}\left( {L}_{\mathrm{P}3}\right) .P$ besides an initialization routine, to set up the execution environment, also contains a finalization routine, to save the content of the registers; moreover, test cases instructions are patched to avoid unwanted control transfers. For further details, see Section 4.3.3. During the execution of the code, the following situations may occur. (I) execution of the code of the test case terminates; (II) a page-fault exception caused by an access to a missing page occurs; (III) a page-fault exception caused by a write access to a non-writable page occurs; (IV) any other exception occurs.

Situation (1) indicates that the entire code of the test case is executed successfully. That means that the instruction in the test case was valid and did not generate any fatal CPU exception. The first type of page-fault exceptions (II) allows us to synchronize lazily the memory containing the data of the test case at the first access. During the initialization phase $\left( {L}_{\mathrm{P}2}\right)$ all the memory pages of the physical environment, but that containing the code (and few others containing the code to run the logic), are protected to prevent any access. Consequently, if an instruction of the test case tries to access the memory, we intercept the access through the page fault exception and we retrieve the entire memory page from the emulated environment $\left( {L}_{\mathrm{P}4}\right.$ and $\left. {L}_{\mathrm{E}5}\right)$ . All data pages retrieved are initially marked as read-only to catch future write accesses. After that, the execution of the code of the test case on the physical CPU is resumed $\left( {L}_{\mathrm{P}5}\right)$ . The second type of page-fault exceptions (III) allows us to intercept write accesses to the memory. Written pages are the only pages that can differ from one environment to the other. Therefore, after a faulty write operation we flag the memory page as written. Then, the page is marked as writable and the execution is resumed $\left( {L}_{\mathrm{P}6}\right.$ and $\left. {L}_{\mathrm{P}7}\right)$ . Obviously, depending on the code of the test case, situations (II) and (III) may occur repeatedly or may not occur at all during the analysis. Finally, the occurrence of any other exception (IV) indicates that the execution of the code of the test case cannot be completed because the CPU is unable to execute an instruction. When the execution of the code of the test case on the physical CPU terminates, because of (I) or (IV), $P$ regains the control of the execution, immediately saves the state of the environment for future comparisons $\left( {L}_{\mathrm{P}8}\right)$ , and restores the state of the CPU prior to the execution of the test case.

Test Case Execution on the Emulated CPU. The execution of the code of the test case in the emulated environment, previously stopped at $p{c}_{E}\left( {L}_{\mathrm{E}2}\right)$ , can now be safely resumed. The execution of the code in the emulated environment must follow the execution in the physical environment and cannot be concurrent with it. This is because in the physical environment the state of the memory is synchronized on-demand and thus the initial state of the memory ${M}_{E}$ must remain untouched until the physical CPU completes the execution of the test case. When this happens the execution is resumed and it terminates when all the code of the test case is executed or an exception occurs ( ${L}_{\mathrm{E}6}$ ).

Comparison of the Final State. When the emulator and the physical environments have completed the execution of the test case, we can compare their state $\left( {{s}_{E}^{\prime } = \left( {p{c}_{E}^{\prime }}\right. }\right.$ , $\left. {{R}_{E}^{\prime },{M}_{E}^{\prime },{E}_{E}^{\prime }}\right)$ and ${s}_{P}^{\prime } = \left( {p{c}_{P}^{\prime },{R}_{P}^{\prime },{M}_{P}^{\prime },{E}_{P}^{\prime }}\right)$ ). The comparison is performed by $P$ . The emulator notifies $P$ and then transfers the program counter $p{c}_{E}^{\prime }$ , the current state of the CPU registers ${R}_{E}^{\prime }$ , and the exception state ${E}_{P}^{\prime }\left( {L}_{\mathrm{E}7}\right)$ . To compare ${s}_{E}^{\prime }$ and ${s}_{P}^{\prime }$ , it is not necessary to compare the entire address space: $\dot{P}$ fetches only the contents of the pages that have been marked as written $\left( {L}_{\mathrm{P}{10}}\right.$ and $\left. {L}_{\mathrm{E}8}\right)$ . At this point ${s}_{E}^{\prime }$ is compared with ${s}_{P}^{\prime }$ $\left( {L}_{\mathrm{P}{11}}\right)$ . If ${s}_{E}^{\prime }$ differs from ${s}_{P}^{\prime }$ , we record the test case and the difference(s) produced.

4.3.2. Embedding the Logic in the CPU Emulator. Program $E$ is run directly in the emulator under analysis. The emulator is extended to include the code of $E$ . We embed the code leveraging the instrumentation API provided by the majority of the emulators. The main functionalities of the embedded code are the following. First, it allows to intercept the beginning and the end of the execution of each instruction (or basic block, depending on the emulator) of the emulated program. If the code of the test case contains multiple instructions, all basic blocks (or instructions) are intercepted and contribute to the testing. We assume the code used to initialize the environment is always correctly emulated and thus we do not test it nor we intercept its execution. Second, the embedded code allows to intercept the exceptions that may occur during the execution of the test case. Third, it provides an interface to access the values of the registers of the CPU and the contents of the memory of the emulator.

4.3.3. Running the Logic on the Physical CPU. On the physical CPU, the test case is run through a user-space program that implements the various steps described in 4.3.1. An initialization routine $\left( {L}_{\mathrm{P}2}\right.$ in Figure 7), is used to set up the registers of the CPU, to register signal handlers to catch page faults and the other run-time exceptions that can arise during the execution of the test case, and to transfer the control to the code of the test case. The code of the test case is executed as a shellcode [Koziol et al. 2004] and consequently we must be sure it does not contain any dangerous control transfer instruction that would prevent us from regain the control of the execution (e.g., jumps, function calls, system calls). Given the approaches we use to generate the code of the test cases, we cannot prevent the generation of such dangerous test cases. Therefore, we rely on a traditional disassembler to analyze the code of the test case, identify dangerous control transfer instructions, and patch the code to regain the control of the execution (e.g., by modifying the target address of direct jump instructions). ${}^{6}$ To prevent endless loops caused by failures of this analysis, we put a limit on the maximum CPU time available for the execution of a test case and we interrupt the execution if the limit is exceeded. In the current implementation, this limit is set to 5s, and has been determined experimentally to guarantee detection of endless loops. At the end of the code of the test case, we append a finalization routine $\left( {L}_{\mathrm{{PS}}}\right.$ in Figure 7), that is used to save the contents of the registers for future comparison, to restore their original contents, and to resume the normal execution of the remaining steps of the logic. Exceptions other than page-faults interrupt the execution of the test case. The handlers of these exceptions record the exception occurred and overwrite the faulty instruction and the following ones with nops, to allow the execution to reach the finalization routine to save the final state of the environment.

In the approach just described, the program $P$ and the test case share the same address space. Therefore, the state of the memory in the physical environment differs slightly from the state of the memory in the emulated environment: some memory pages are used to store the code and the data of the user-space program, through which we run the test case. If the code of the test case accesses any of these pages, we would notice a spurious difference in the state of the two environments. Considering that the occurrence of such event is highly improbable, we decided to neglect this problem, to avoid complicating the implementation.

## 5. EVALUATION

This section presents the results we obtained by testing five IA-32 emulators with EmuFuzzer: three process emulators (QEMU, Valgrind, and Pin) and two system emulator (BOCHS and JPC). Specifically, we chose QEMU and BOCHS because they are the most widely used IA-32 emulators, Valgrind and Pin because, despite them being dynamic instrumentation tools, their internal architecture resembles the architecture of a traditional emulator, and finally JPC because it is an IA-32 emulator fully developed in Java language and therefore portable on several platforms and devices (e.g., mobile devices).

We generated a large number of test cases, evaluated their quality, and fed them to the five emulators. None of the emulators tested turned out to be faithful. In each of them, we found different classes of defects: small deviations in the contents of the status register after arithmetical and logical operations, improper exception raising, incorrect decoding of instructions, and even crash of the emulator. Our experimental results lead to the following conclusions: (I) developing a CPU emulator is actually very challenging, (II) developers of these software would highly benefit from specialized testing methodology, and (III) EmuFuzzer proved to be a very effective tool for testing CPU emulators.

---

${}^{6}$ If the disassembler failed to detect dangerous control transfer instructions, we could not be able to regain the control of the execution properly.

---

#### 5.1.A Glimpse at the Implementation

The current EmuFuzzer implementation consists of three interconnected components: a coordinator and two drivers (one for the physical CPU, and one for the emulator under analysis). The coordinator supervises the execution of a test case. The driver that controls the execution on the physical CPU is independent from any specific emulator. On the contrary, the driver for CPU emulator augments a specific emulator with the features needed to intercept the execution of a single instruction and to inspect the execution state; this driver is obviously emulator-specific, and we implemented a different emulator driver for each CPU emulator we considered in our experiments.

For a given test case, $s$ , the coordinator first leverages the emulator driver to set up the emulated execution environment: CPU registers and memory locations are initialized as specified by $s$ . Subsequently, as just mentioned in Section 4.3, the coordinator starts executing the test case on the physical processor. Such an execution may require the setting of some CPU registers or memory locations, that are thus fetched from the emulated environment and replicated into the physical one. Once the execution of the test case completes, the processor final state ${\delta }_{{\mathcal{C}}_{P}}\left( s\right)$ is dumped to a file. At this point the coordinator starts the execution of $s$ on the emulator. Also in this case the final state of the computation, ${\delta }_{{\mathcal{C}}_{E}}\left( s\right)$ will be dumped to a file. Then, the coordinator compares ${\delta }_{{\mathcal{C}}_{P}}\left( s\right)$ and ${\delta }_{{\mathcal{C}}_{E}}\left( s\right)$ .

The coordinator is written in Python ( $\sim  {750}$ noncomment lines of code), while the CPU driver consists of roughly 1200 noncomment lines of C++ code. Finally, emulator drivers are written in the same language of the target emulator, typically C. On average, an emulator driver requires about 450 noncomment lines of code (of these, 350 lines are emulator-independent and are shared between all emulator drivers). Communication between the coordinator and the drivers relies on the XML-RPC protocol.

### 5.2. Experimental Setup

We performed the evaluation of our testing methodology and tool using an Intel Pentium $4\left( {{3.0}\mathrm{{GHz}}}\right)$ , running Debian GNU/Linux with kernel 2.6.26, as baseline physical CPU. The physical CPU supported the following features: MMX, SSE, SSE2, and SSE3. We tested the following release of each emulator, namely: QEMU 0.9.1, Valgrind 3.3.1, Pin 2.5-23100, JPC 2.4, and BOCHS 2.3.7. The features of the physical machine were compatible with the features of the tested emulators with few exceptions, which we identified at the end of the testing, using a traditional disassembler, and ignored (e.g., BOCHS also supports SSE4).

### 5.3. Evaluation of Test Case Generation

We generated about 3 million test cases, 70% of which using our CPU-assisted algorithm and the remaining ${30}\%$ randomly. We empirically estimated the completeness of the set of instructions covered by the generated test cases by disassembling the code of the test cases, by counting the number of different instructions found (operands were ignored), and by comparing this number with the total number of mnemonic instructions recognized by the disassembler. The randomly generated test cases covered about ${75}\%$ of the total number of instructions, while the test cases generated using our CPU-assisted algorithm covered about ${62}\%$ . Overall, about ${81}\%$ of the instructions supported by the disassembler were included in the test cases used for the evaluation. It is worth noting that in several cases our test cases contained valid instructions not recognized by the disassembler.

Table II. Results of the Evaluation: Number of Distinct Mnemonic Opcodes (OP) and Number of Test Cases (TC) that Triggered Deviations in the Behavior between the Tested Emulators and the Baseline Physical CPU

<table><tr><td colspan="2" rowspan="2">Deviation type</td><td colspan="2">QEMU</td><td colspan="2">Valgrind</td><td colspan="2">Pin</td><td colspan="2">BOCHS</td><td colspan="2">JPC</td></tr><tr><td>${OP}$</td><td>${TC}$</td><td>${OP}$</td><td>${TC}$</td><td>${OP}$</td><td>${TC}$</td><td>${OP}$</td><td>${TC}$</td><td>${OP}$</td><td>${TC}$</td></tr><tr><td rowspan="3">$R$</td><td>CPU flags</td><td>39</td><td>1362</td><td>13</td><td>684</td><td>22</td><td>2180</td><td>2</td><td>2686</td><td>33</td><td>4088</td></tr><tr><td>CPU general</td><td>3</td><td>142</td><td>8</td><td>141</td><td>3</td><td>18</td><td>8</td><td>8</td><td>27</td><td>657</td></tr><tr><td>${FPU}$</td><td>179</td><td>41738</td><td>157</td><td>39473</td><td>0</td><td>0</td><td>71</td><td>1631</td><td>185</td><td>43024</td></tr><tr><td>$M$</td><td>memory state</td><td>34</td><td>1586</td><td>10</td><td>420</td><td>0</td><td>0</td><td>1</td><td>2</td><td>46</td><td>2122</td></tr><tr><td rowspan="3">$E$</td><td>not supported</td><td>2</td><td>1120</td><td>334</td><td>11513</td><td>2</td><td>12</td><td>0</td><td>0</td><td>8</td><td>1998</td></tr><tr><td>over supported</td><td>97</td><td>1859</td><td>10</td><td>716</td><td>0</td><td>0</td><td>5</td><td>8</td><td>124</td><td>1930</td></tr><tr><td>other</td><td>126</td><td>6069</td><td>41</td><td>6184</td><td>20</td><td>34</td><td>45</td><td>113</td><td>132</td><td>5935</td></tr><tr><td/><td>Total</td><td>405</td><td>53926</td><td>529</td><td>59135</td><td>43</td><td>2245</td><td>130</td><td>4469</td><td>482</td><td>59354</td></tr></table>

The implementation of our CPU-assisted algorithm is not complete and lacks support for all instructions with prefixes. For example, currently our algorithm does not generate test cases involving instructions operating on 16-bits operands. We have empirically estimated that instructions with prefixes represent more than 25% of the instructions space. Therefore, a complete implementation of the algorithm would allow to achieve a nearly total coverage. We speculate that the high coverage of randomly generated test cases is due to the fact that the IA-32 instruction set is very dense and consequently a random bytes stream can be interpreted as a series of valid instructions with high probability. Nevertheless, during our empirical evaluation we reached a local optimum from which it was impossible to move away, even after having generated hundreds of thousands of new test cases. The CPU-assisted algorithm instead does not suffer this kind of problem: a complete implementation would allow to generate a finite number of test cases exercising all instructions in multiple corner cases.

### 5.4. Testing of IA-32 Emulators

The five CPU emulators were tested using a small subset $\left( { \sim  {10}\% }\right)$ of the generated test cases, selected randomly. The whole testing took about a day for all the emulators but JPC, at the speed of around 15 test cases per second (JPC alone took several days to run all the test cases). Table II reports the results of our experiments. Behavioral differences found are grouped into three categories: CPU registers state(R), memory state(M), and exception state(E). Differences in the state of the registers are further separated according to the type of the registers: status (CPU flags), general purpose and segment (CPU general), and floating-point (FPU). Differences in the exception state are separated in: legal instructions not supported by the emulator (not supported), illegal instructions valid for the emulator (over supported), and other deviations in the exception state (other). As an example, the last class includes instructions that expect aligned operands but execute without any exception even if the constraint is not satisfied. For each emulator and type of deviation, the table reports the number of distinct mnemonic opcodes leading to the identification of that particular type of deviation (opcodes) and the number of test cases proving the deviation (test cases). It is worth pointing out that different combinations of prefixes and opcodes are considered as different mnemonic opcodes. For each distinct opcode that produced a particular type of deviation, we verified and confirmed manually the correctness of at least one of the results found.

The results demonstrate the effectiveness of the proposed testing methodology. For each emulator we found several mnemonic opcodes not faithfully emulated: 405 in QEMU, 529 in Valgrind, 43 in Pin, 130 in BOCHS and 482 in JPC. It is worth noting that some of the deviations found might be caused by too lax specifications of the physical CPU. For example, the manufacturer documentation of the add instruction precisely states the effect of the instruction on the status register, while the documentation of the and instruction only states the effect on some bits of the status register, while leaving undefined the value the remaining bits [Intel 2008]. Our reference of the specification is the CPU itself and consequently, with respect to our definition of faithful emulation, any deviation has to be considered a tangible defect. Indeed, for each deviation discovered by EmuFuzzer it is possible to write a program that executes correctly in the physical CPU, but crashes in the emulated CPU (or vice-versa). We manually transformed some of the problematic test cases into this kind of programs and verified the correctness of our claim. The remarkable number of defects found also witnesses the difficulty of developing a fully featured and specification-compliant CPU emulator and motivates our conviction about the need of a proper testing methodology.

The following paragraphs summarize the defects we found in each emulator. The description is very brief because the intent is not criticize the implementation of the tested emulators, but just to show the strength of EmuFuzzer at detecting various classes of defects.

In Paleari et al. [2011], we release all the improper behaviors we detected in the emulators supported by EmuFuzzer. Developers were informed about the defects found in their emulators, providing them with the corresponding test cases.

5.4.1. QEMU. A number of arithmetical and logical instructions are not properly executed by the emulator because of an error in the routine responsible for decoding certain encoding of memory operands (e.g., or %edi, 0x67(%ebx) encoded as 087c e367); the instructions reference the wrong memory locations and thus compute the wrong results. The emulator accepts several illegal combinations of prefixes and opcodes and executes the instruction ignoring the prefixes (e.g., lock fcos). Floating-point instructions that require properly aligned memory operands are executed without raising any exception even when the operands are not aligned, because the decoding routine does not perform alignment checking (e.g., fxsave 0x00012345). Segments registers, which are 16 bits wide, are emulated as 32-bit registers (the unused bits are set to zero), thus producing deviations when they are stored in other 32-bits registers and in memory (e.g., push %fs). Some arithmetic and logical instructions do not faithfully update the status register. Finally, we found sequences of bytes that freeze and others that crash the emulator (e.g., xgetbv).

5.4.2. Valgrind. Some instructions have multiple equivalent encodings (i.e., two different opcodes encode the same instruction) but the emulator does not recognize all the encodings and thus the instructions are considered illegal (e.g., addb \$0x47, %ah with opcode 82). Several legal privileged instructions, when invoked with insufficient privileges, do not raise the appropriate exceptions (e.g., mov (%ecx), %cr3 raises an illegal operation exception instead of a general protection fault). On the physical CPU, each instruction is executed atomically and, consequently, when an exception occurs the state of the memory and of the registers correspond to the state preceding the execution of the instruction. On Valgrind instead, instructions are not executed atomically because they are translated into several intermediate instructions. Consequently, if an exception occurs in the middle of the execution of an instruction, the state of the memory and of the registers might differ from the state prior to the execution of the instruction (e.g., idiv (%ecx) when the divisor is zero). As in QEMU, some logical instructions do not faithfully update the status register.

5.4.3. Pin. Not all exceptions are properly handled (i.e., trap and illegal instruction exceptions); Pin does not notify the emulated program about these exceptions. Several legal instructions that raise a general protection fault on the physical CPU are executed without generating any exception on Pin (e.g., add %ah, %fs: (%ebx)). When segment registers are stored (and removed) in the stack, the stack pointer is not updated properly: a double-word should be reserved on the stack for these registers, but Pin reserves a single word (e.g., push %fs). The FPU appears to be virtualized (i.e., the floating-point code is executed directly on the physical FPU) and, as expected, no deviation is detected in the execution of FPU instructions. As in Valgrind and QEMU, some logical instructions do not faithfully update the status register.

5.4.4. BOCHS. Certain floating-point instructions alter the state of some registers of the FPU and other instructions compute results that differ from those computed by the FPU of the physical CPU (e.g., fadd %st0, %st7). If an exception occurs in the middle of the execution of an instruction manipulating the stack, the initial contents of the stack pointer corresponds to that we would have if the instruction were successfully executed (e.g., pop 0xffffffff). Some instructions do not raise the proper exception (e.g., int 1 raises a general protection fault instead of a trap exception). As in Valgrind, QEMU, and Pin, some logical instruction do not faithfully update the status register, although the number of such instruction is smaller than the number of instructions affected by this problem in the other emulators.

5.4.5. JPC. Conversely to the other emulators, which are written in $\mathrm{C}$ and $\mathrm{C} +  + ,\mathrm{{JPC}}$ is fully developed in Java. It turned out that one of the main problems we had to deal with for testing this emulator was its poor performances executing test cases: JPC is approximately 75% slower than any other emulator. A description of the main deviations found follows. Segment registers, which are 16-bits wide, are emulated as 32-bit registers. This implies deviations when segment registers are stored in other 32-bits registers and in memory (e.g., push %gs). Several legal privileged instructions, when invoked with insufficient privileges, do not raise the appropriate exceptions (e.g., mov (%ecx), %cr0 and mov %cr3, %eax are correctly executed when the CPU is in user mode without raising a general protection fault exception). As in QEMU, the emulator accepts illegal combination of prefixes and executes the instruction ignoring them (e.g., lock fcos). Moreover, not all exceptions are properly handled (i.e., illegal instruction exceptions) and some instructions do not raise the appropriate exception. To conclude, we found several sequences of bytes that crash the emulator (e.g., bound %eax, (%bx) and int 1).

## 6. DISCUSSION

EmuFuzzer currently works in user-space and thus it can only verify whether unprivileged code is not emulated faithfully, with few exceptions. For example, some unprivileged instructions that access segment registers might not be tested because it is not possible to manipulate properly the value of these registers from user-space. Fortunately, in many cases the values of the segment registers in the emulated and in the physical environments do not need to be manipulated as they already match. Another limitation is that, from user-space, we cannot manipulate control registers and thus we cannot enable supplementary CPU-enforced alignment checking and the other enforcements it offers, which are disabled by default. In the future we plan to port the component running in the physical environment of EmuFuzzer in kernel-space, to be able to perform a more thorough testing. Furthermore, we plan to test new CPU emulators and also to use EmuFuzzer to test the emulation routines adopted by virtual machines to emulate non-virtualizable instructions (i.e., privileged instructions that do not cause a trap if executed with insufficient privileges [Robin and Irvine 2000]). As an example, VirtualBox [Sun Microsystem 2011] leverages QEMU code for that purpose.

## 7. RELATED WORK

### 7.1. Software Testing

Fuzz-testing has been introduced by Miller et al. [1990], and it is still widely used for testing different types of applications. Originally, fuzz-testing consisted of feeding applications purely random input data and detecting which inputs were able to crash an application, or to cause unexpected behaviors. Today, this testing methodology is used to test many different types of applications; for example, GUI applications, web applications, scripts, and kernel drivers [DeMott 2006].

As certain applications require inputs with particular format (e.g., a XML document or a well-formed Java program), pure randomly generated inputs cannot guarantee a reasonable coverage of the code of the application under analysis. Recently developed testing techniques typically leverage domain specific knowledge and use this knowledge, optionally in tandem with a random component, to drive inputs generation [Daniel et al. 2007; Kaksonen 2001; Sutton et al. 2007]. An alternative approach to improve the completeness of the testing consists of building constraints that describe what properties are required for the input to trigger the execution of particular program paths, and in using a constraint solver to find inputs with these properties [Cadar et al. 2006; Godefroid et al. 2008; Sen et al. 2005; Majumdar and Sen 2007; Xu et al. 2010; Santelices and Harrold 2010]. This article presents a fuzz-testing methodology specific for CPU emulators that leverages both pure random inputs generation and domain knowledge to improve the completeness of the analysis.

In our previous works, we explored the idea of using mechanically generated tests and to compare the behavior of two components to detect deviations imputable to bugs [Paleari et al. 2010; Martignoni et al. 2009, 2010]. This approach is known in literature as differential testing [McKeeman 1998; Lahiri et al. 2010; Person et al. 2008; Taneja et al. 2011]. EmuFuzzer adopts differential testing to detect if the tested CPU emulator behaves unfaithfully with respect to the physical CPU emulated.

### 7.2. Computer Security

CPU emulators are widely used in computer security for various purposes. One of the most common applications is malware analysis [Bayer et al. 2006; Martignoni et al. 2008]. Emulators allow fine-grained monitoring of the execution of a suspicious programs and to infer high-level behaviors. Furthermore, they allow to isolate the execution and to easily checkpoint and restore the state of the environment. Malware authors, aware of the techniques used to analyze malware, aim at defeating those techniques such that their software can survive longer. To defeat dynamic behavioral analysis based on emulators, they typically introduce in malware routines able to detect if a program is run in an emulated or in a physical environment. As the average user targeted by the malware does not use emulators, the presence of an emulated environment likely indicates that the program is being analyzed. Thus, if the malicious program detects the presence of an emulator, it starts to behave innocuously such that the analysis does not detect any malicious behavior. Several researchers have analyzed state-of-the-art emulators to find unfaithful behaviors that could be used to write specific detection routines [Ormandy 2007; Raffetseder et al. 2007; Rutkowska 2004; Oberheide and Miller 2012]. Unfortunately for them, their results were obtained through a manual scrutiny of the source code or rudimentary fuzzers, and thus the results are largely incomplete. The testing technique presented in this paper can be used to find automatically a large class of the unfaithful behaviors that a miscreant could use to detect the presence of an emulated CPU. This information could then be used to harden an emulator, to the point that it satisfies the requirements for undetectability identified by Dinaburg et al. [2008].

## 8. CONCLUSIONS

CPU emulators are complex pieces of software. In this article, we presented a testing methodology for CPU emulators, based on fuzzing. Emulators are tested by generating test case programs and by executing them on the emulated and on the physical CPUs. As the physical CPU is assumed to follow perfectly the specification, defects in the emulators can be detected by comparing the state of the emulator with that of the physical CPU, after the execution of the test case program. The proposed methodology has been implemented in a prototype, named as EmuFuzzer, and it was used to test five state-of-the-art IA-32 CPU emulators. EmuFuzzer discovered minor and major defects in each of the tested emulators, thus demonstrating the effectiveness of the proposed approach.

## REFERENCES

Bayer, U., Kruegel, C., AND KIRDA, E. 2006. TTAnalyze: A tool for analyzing malware. In Procedings of the 15th European Institute for Computer Antivirus Research Annual Conference (EICAR'06).

BELLARD, F. 2005. QEMU, a fast and portable dynamic translator. In Proceedings of the Annual Conference on USENIX Annual Technical Conference. USENIX Association.

Cadar, C., Ganesh, V., Pawlowski, P. M., Dill, D. L., and Englere, D. R. 2006. EXE: Automatically generating inputs of death. In Proceedings of the 13th ACM Conference on Computer and Communications Security. ACM.

DANIEL, B., DIG, D., GARCIA, K., AND MARINOV, D. 2007. Automated testing of refactoring engines. In Proceedings of the 6th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT International Symposium on Foundations of Software Engineering. ACM.

DEMOTT, J. 2006. The evolving art of fuzzing. Def. Con 14.

DINABURG, A., Royal, P., SHARIF, M., AND LEE, W. 2008. Ether: Malware analysis via hardware virtualization extensions. In Proceedings of the 15th ACM conference on Computer and Communications Security. ACM.

FERRIE, P. 2006. Attacks on virtual machine emulators. Tech. rep., Symantec Advanced Threat Research.

GARFINKEL, T. AND ROSENBLUM, M. 2003. A virtual machine introspection based architecture for intrusion detection. In Proceedings of Network and Distributed Systems Security Symposium (NDSS). The Internet Society, San Diego, CA.

GODEFROID, P., LEVIN, M. Y., AND MOLNAR, D. 2008. Automated whitebox fuzz testing. In Proceedings of the Network and Distributed System Security Symposium (NDSS). The Internet Society, San Diego, CA.

Google Inc. 2011. Android emulator. http://code.google.com/android/reference/emulator.html.

INTEL. 2008. Intel 64 and IA-32 Architectures Software Developer’s Manual. Intel. Instruction Set Reference. KAKSONEN, R. 2001. A functional method for assessing protocol implementation security. Tech. rep., VTT Electronics.

Koziol, J., Litchfield, D., Aittel, D., Anicey, C., Eren, S., Mehta, N., and Hassell, R. 2004. The Shellcoder's Handbook: Discovering and Exploiting Security Holes. Wiley.

LAHIRI, S. K., VASWANI, K., AND HOARE, C. A. R. 2010. Differential static analysis: opportunities, applications, and challenges. In Proceedings of the Workshop on Future of Software Engineering Research (FoSER'10), ACM, 201-204.

Lawton, K. P. 1996. Bochs: A portable PC emulator for unix/x. Linux J. 1996, 29es.

LICHSTEIN, H. A. 1969. When should you emulate? Datamation 11, 205-210.

Luk, C., Cohn, R., Muтн, R., Patil, H., Klauser, A., Lowney, G., Wallace, S., REDdi, V. J., And Hazelwood, K. 2005. Pin: Building customized program analysis tools with dynamic instrumentation. In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI). ACM.

Magnusson, P. S., Christensson, M., Eskilson, J., Forsgren, D., Hallberg, G., Högberg, J., Larsson, F., MoestEDT, A., AND WERNER, B. 2002. Simics: A full system simulation platform. Computer 35, 50-58.

Majumdar, R. AND Sen, K. 2007. Hybrid concolic testing. In Proceedings of the 29th International Conference on Software Engineering (ICSE). IEEE Computer Society.

Martignoni, L., Paleari, R., Fresi Rogili, G., AND Bruschi, D. 2009. Testing CPU emulators. In Proceedings of the International Conference on Software Testing and Analysis (ISSTA). ACM, 261-272.

Martignoni, L., Palearai, R., Fresi Rogl.ia, G., AND Bruschi, D. 2010. Testing system virtual machines. In Proceedings of the International Symposium on Testing and Analysis (ISSTA).

Martignoni, L., Strnson, E., Frednikson, M., JнА, S., and Mitchell, J. C. 2008. A layered architecture for detecting malicious behaviors. In Proceedings of the International Symposium on Recent Advances in Intrusion Detection (RAID). Lecture Notes in Computer Science, Springer, Berlin.

McKeeman, W. M. 1998. Differential testing for software. Digital Tech. J. 10, 1, 100-107.

Miller, B. P., Fredrikson, L., AND So, B. 1990. An empirical study of the reliability of UNIX utilities. Comm. ${ACM33},{12}$ .

Myers, G. J. 1978. The Art of Software Testing. Wiley.

netbsd64 2011. NetBSD/amd64. http://www.netbsd.org/ports/amd64/.

NETHERCOTE, N. 2004. Dynamic binary analysis and instrumentation. Ph.D. thesis, Computer Laboratory, University of Cambridge, UK.

OberHEIDE, J. AND MILLER, C. 2012. Dissecting the Android bouncer. SummerCon, Brooklyn, NY. http://jon.oberheide.org/files/summercon12-bouncer.pdf.

Ormandy, T. 2007. An empirical study into the security exposure to host of hostile virtualized environments. In Proceedings of CanSecWest Applied Security Conference.

PaleaRi, R., Martignoni, L., Fresi Roglia, G., and Bruschi, D. 2010. N-version disassembly: Differential testing of $\times  {86}$ disassemblers. In Proceedings of the International Symposium on Testing and Analysis (ISSTA). ACM.

Palceari, R., Martiguoni, L., Reina, A., Fresi Roglia, G., and Bruschi, D. 2011. EmuFuzzer Red-Pills Archive. http://security.di.unimi.it/emufuzzer.html.

PERSON, S., DWYER, M. B., ELBAUM, S., AND PXSAREANU, C. S. 2008. Differential symbolic execution. In Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering. ACM, 226-237.

Preston, I., Newman, R., and Tsens, J. 2007. JPC: The pure Java ×86 PC emulator. http://jpc.sourceforge.net/home_home.html.

QUIST, D. AND SMITH, V. 2006. Detecting the presence of virtual machines using the local data table. Offensive Computing. http://www.offensivecomputing.net/files/active/0.vm.pdf.

RAFFETSEDER, T., KRUEGEL, C., AND KIRDA, E. 2007. Detecting system emulators. In Proceedings of the Information Security Conference (ISC'07). Springer-Verlag.

Robin, J. S. AND IRVINE, C. E. 2000. Analysis of the intel pentium's ability to support a secure virtual machine monitor. In Proceedings of the 9th Conference on USENIX Security Symposium (SSYMM'00). USENIX Association.

RUTKOWSKA, J. 2004. Red Pill. . . or how to detect VMM using (almost) one CPU instruction. http://www.ouah.org/Red-%20Pill.html.

Santelices, R. A. AND HARROLD, M. J. 2010. Exploiting program dependencies for scalable multiple-path symbolic execution. In Procedings of the International Symposium on Software Testing and Analysis (ISSTA’10). ACM, 195-206.

SEN, K., MARINOV, D., AND AGHA, G. 2005. CUTE: A concolic unit testing engine for C. In Proceedings of the 10th European Software Engineering Conference. ACM.

Sun Microsystem. 2011. VirtualBox. http://www.virtualbox.org.

Sutton, M., Greene, A., AND AMINI, P. 2007. Fuzzing: Brute Force Vulnerability Discovery. Addison-Wesley Professional.

TANEJA, K., XIE, T., TILLMANN, N., DE HALLEUX, J., AND DE HALLEUX, P. 2011. eXpress: Guided path exploration for efficient regression test generation. In Procedings of the 2011 International Symposium on Software Testing and Analysis (ISSTA'11). ACM.

Xu, Z., Kim, Y., Kim, M., RorthermoL, G., AND Cohen, M. B. 2010. Directed test suite augmentation: techniques and tradeoffs. In Proceedings of the 18th ACM SIGSOFT International Symposium on Foundations of Software Engineering. 257-266.